<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Kolebri - The Game</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      touch-action: none;
      width: 100%;
      height: 100vh;
    }
    canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
</head>
<body>
<script>
let bird, treeImg, upperTreeImg, pineconeImg, bgImg;
let newBird, newTreeImg, newUpperTreeImg, newPineconeImg, newBgImg;
let birdX, birdY, birdVelocity, gravity;
let trees = [];
let pinecones = [];
let score = 0;
let gameState = 'start';
let quiz = null;
let quizTimer = 0;
let obstaclesPassed = 0;
let quizFade = 0;
let hoverIndex = -1;
let scaleFactor = 1;
let confetti = [];
let correctAnswers = 0;
let totalQuestionsAnswered = 0;
let quizResultMessage = '';
let quizResultTimer = 0;
let shuffledQuestions = [];
let currentQuestionIndex = 0;
let obstaclePauseTimer = 0;
let restartDelayTimer = 0;
let gravityActive = false;
let startDelayTimer = 0;
let confettiPlayed = false;

const quizQuestions = [
  {
    question: "Welcher Baum verströmt im Sommer einen besonders süßen Duft?",
    options: ["Birke", "Ahorn", "Linde", "Tanne"],
    correct: 2
  },
  {
    question: "Welcher Baum hat weiße, schimmernde Rinde?",
    options: ["Buche", "Birke", "Eiche", "Hainbuche"],
    correct: 1
  },
  {
    question: "Welcher Baum verliert als Nadelbaum im Herbst seine Nadeln?",
    options: ["Fichte", "Kiefer", "Tanne", "Lärche"],
    correct: 3
  },
  {
    question: "Welche Baumart bildet kleine „Propeller“-Samen aus?",
    options: ["Eiche", "Tulpenbaum", "Ahorn", "Hainbuche"],
    correct: 2
  },
  {
    question: "Welcher Baum hat tief eingeschnittene Blätter und bildet Eicheln?",
    options: ["Ahorn", "Buche", "Eiche", "Kirsche"],
    correct: 2
  },
  {
    question: "Welcher Baum hat auffällige, trompetenförmige Blüten?",
    options: ["Linde", "Tulpenbaum", "Ahorn", "Tanne"],
    correct: 1
  },
  {
    question: "Welcher Baum ist mit Weihnachten besonders verbunden?",
    options: ["Tanne", "Birke", "Kirsche", "Linde"],
    correct: 0
  },
  {
    question: "Welche Blätter sind herzförmig?",
    options: ["Eichenblätter", "Lindenblätter", "Ahornblätter", "Buchenblätter"],
    correct: 1
  },
  {
    question: "Welche Baumart hat eine sehr dichte Krone und ledrige Blätter?",
    options: ["Hainbuche", "Ahorn", "Kirsche", "Birke"],
    correct: 0
  },
  {
    question: "Welcher Baum ist im Frühling mit rosa oder weißen Blüten bedeckt?",
    options: ["Tulpenbaum", "Buche", "Kirsche", "Weide"],
    correct: 2
  },
  {
    question: "Welche Baumart ist besonders biegsam und oft in Wassernähe zu finden?",
    options: ["Linde", "Birke", "Weide", "Buche"],
    correct: 2
  },
  {
    question: "Wie viele unterschiedliche Baumarten kann man entlang des Lehrpfades entdecken?",
    options: ["7", "9", "11", "13"],
    correct: 2
  },
  {
    question: "Welche Baumart ist sowohl in Baumraum 1, 2 als auch 3 vertreten?",
    options: ["Tanne", "Tulpenbaum", "Birke", "Kirsche"],
    correct: 2
  },
  {
    question: "Wo beginnt der Baumlehrpfad?",
    options: ["Bei der Turnhalle", "Beim Schulbüro", "Beim JUZ / Parkplatz", "Beim Fußballfeld"],
    correct: 2
  },
  {
    question: "Welche Baumart hat eine besonders glatte und graue Rinde?",
    options: ["Hainbuche", "Buche", "Eiche", "Ahorn"],
    correct: 1
  }
];

function preload() {
  try {
    // Lade die Bilder mit relativen Pfaden, mit Fallback auf Platzhalterbilder
    newBgImg = loadImage('./background.jpg', 
      () => console.log('New Background loaded successfully'), 
      () => {
        console.error('Failed to load ./background.jpg, using placeholder');
        bgImg = loadImage('https://images.pexels.com/photos/38136/pexels-photo-38136.jpeg', 
          () => console.log('Background placeholder loaded successfully'), 
          () => console.error('Failed to load background placeholder image')
        );
      }
    );

    newTreeImg = loadImage('./stammunten.png', 
      () => console.log('New Lower Obstacle loaded successfully'), 
      () => {
        console.error('Failed to load ./stammunten.png, using placeholder');
        treeImg = loadImage('https://images.pexels.com/photos/1612351/pexels-photo-1612351.jpeg', 
          () => console.log('Lower Obstacle placeholder loaded successfully'), 
          () => console.error('Failed to load lower obstacle placeholder image')
        );
      }
    );

    newUpperTreeImg = loadImage('./stammoben.png', 
      () => console.log('New Upper Obstacle loaded successfully'), 
      () => {
        console.error('Failed to load ./stammoben.png, using placeholder');
        upperTreeImg = loadImage('https://images.pexels.com/photos/164353/pexels-photo-164353.jpeg', 
          () => console.log('Upper Obstacle placeholder loaded successfully'), 
          () => console.error('Failed to load upper obstacle placeholder image')
        );
      }
    );

    newPineconeImg = loadImage('./zapfen.png', 
      () => console.log('New Zapfen loaded successfully'), 
      () => {
        console.error('Failed to load ./zapfen.png, using placeholder');
        pineconeImg = loadImage('https://images.pexels.com/photos/380284/pexels-photo-380284.jpeg', 
          () => console.log('Zapfen placeholder loaded successfully'), 
          () => console.error('Failed to load zapfen placeholder image')
        );
      }
    );
  } catch (e) {
    console.error('Error in preload:', e);
  }
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  scaleFactor = min(windowWidth / 800, windowHeight / 600);
  birdX = width / 4;
  birdY = height / 2;
  birdVelocity = 0;
  gravity = 0.5 * scaleFactor;
  trees = [];
  pinecones = [];
  score = 0;
  obstaclesPassed = 0;
  gameState = 'start';
  correctAnswers = 0;
  totalQuestionsAnswered = 0;
  quizResultMessage = '';
  quizResultTimer = 0;
  obstaclePauseTimer = 0;
  restartDelayTimer = 0;
  gravityActive = false;
  startDelayTimer = 0;
  confettiPlayed = false;
  
  // Mische die Fragen in zufälliger Reihenfolge
  shuffledQuestions = [...quizQuestions];
  for (let i = shuffledQuestions.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shuffledQuestions[i], shuffledQuestions[j]] = [shuffledQuestions[j], shuffledQuestions[i]];
  }
  currentQuestionIndex = 0;
  
  for (let i = 0; i < 3; i++) {
    spawnTree(width + i * 300 * scaleFactor);
  }
  textFont('Montserrat');
}

function draw() {
  clear();
  background(0, 100, 0);

  // Hintergrundbild proportional skalieren (Cover-Methode)
  if (newBgImg && newBgImg.width > 0) {
    let imgAspect = newBgImg.width / newBgImg.height;
    let canvasAspect = width / height;
    let imgWidth, imgHeight, imgX, imgY;

    if (imgAspect > canvasAspect) {
      // Bild ist breiter als der Canvas: Skaliere nach Höhe
      imgHeight = height;
      imgWidth = height * imgAspect;
      imgX = (width - imgWidth) / 2;
      imgY = 0;
    } else {
      // Bild ist höher als der Canvas: Skaliere nach Breite
      imgWidth = width;
      imgHeight = width / imgAspect;
      imgX = 0;
      imgY = (height - imgHeight) / 2;
    }
    image(newBgImg, imgX, imgY, imgWidth, imgHeight);
  } else if (bgImg) {
    let imgAspect = bgImg.width / bgImg.height;
    let canvasAspect = width / height;
    let imgWidth, imgHeight, imgX, imgY;

    if (imgAspect > canvasAspect) {
      imgHeight = height;
      imgWidth = height * imgAspect;
      imgX = (width - imgWidth) / 2;
      imgY = 0;
    } else {
      imgWidth = width;
      imgHeight = width / imgAspect;
      imgX = 0;
      imgY = (height - imgHeight) / 2;
    }
    image(bgImg, imgX, imgY, imgWidth, imgHeight);
  }

  if (gameState === 'start') {
    fill(0, 0, 0, 200);
    rect(0, 0, width, height, 15);

    textAlign(CENTER);
    drawingContext.shadowBlur = 10;
    drawingContext.shadowColor = 'rgba(255, 255, 255, 0.5)';
    fill(255);
    textSize(48 * scaleFactor);
    text("Kolebri - The Game", width / 2, height / 3);
    drawingContext.shadowBlur = 0;

    let btnWidth = max(200 * scaleFactor, 200);
    let btnHeight = max(60 * scaleFactor, 60);
    let btnX = width / 2;
    let btnY = height / 2 + 50 * scaleFactor;
    hoverIndex = -1;
    if (mouseX > btnX - btnWidth / 2 && mouseX < btnX + btnWidth / 2 &&
        mouseY > btnY - btnHeight / 2 && mouseY < btnY + btnHeight / 2) {
      hoverIndex = 0;
    }
    let baseColor = color(139, 69, 19);
    let hoverColor = color(92, 46, 13);
    let buttonColor = hoverIndex === 0 ? hoverColor : baseColor;
    drawingContext.shadowBlur = 10;
    drawingContext.shadowColor = 'rgba(0, 0, 0, 0.3)';
    fill(buttonColor);
    noStroke();
    rectMode(CENTER);
    rect(btnX, btnY, btnWidth, btnHeight, 15);
    drawingContext.shadowBlur = 0;
    drawingContext.shadowBlur = 5;
    drawingContext.shadowColor = 'rgba(0, 0, 0, 0.5)';
    fill(255);
    textSize(24 * scaleFactor);
    text("Spiel Starten", btnX, btnY + 7 * scaleFactor);
    drawingContext.shadowBlur = 0;

    // Hinweis für Leertaste hinzufügen
    drawingContext.shadowBlur = 5;
    drawingContext.shadowColor = 'rgba(0, 0, 0, 0.5)';
    fill(255);
    textSize(20 * scaleFactor);
    text("Drücke die Leertaste zum Spielen", width / 2, btnY + btnHeight / 2 + 30 * scaleFactor);
    drawingContext.shadowBlur = 0;
  } else if (gameState === 'playing') {
    if (startDelayTimer > 0) {
      startDelayTimer--;
      if (startDelayTimer <= 0) {
        gravityActive = true;
      }
    }

    if (gravityActive) {
      birdVelocity += gravity;
      birdY += birdVelocity;
    }

    if (newBird && newBird.width > 0) {
      image(newBird, birdX - 25 * scaleFactor, birdY - 25 * scaleFactor, 50 * scaleFactor, 50 * scaleFactor);
    } else if (bird && bird.width > 0) {
      image(bird, birdX - 25 * scaleFactor, birdY - 25 * scaleFactor, 50 * scaleFactor, 50 * scaleFactor);
    } else {
      fill(255, 0, 0);
      rect(birdX - 25 * scaleFactor, birdY - 25 * scaleFactor, 50 * scaleFactor, 50 * scaleFactor);
    }

    if (birdY > height || birdY < 0) {
      resetGame();
    }

    for (let i = trees.length - 1; i >= 0; i--) {
      let tree = trees[i];
      tree.x -= 2 * scaleFactor;

      // Zeichne das obere Hindernis mit Fallback
      if (newUpperTreeImg && newUpperTreeImg.width > 0) {
        image(newUpperTreeImg, tree.x, 0, 100 * scaleFactor, tree.gapY - 100 * scaleFactor);
      } else if (upperTreeImg && upperTreeImg.width > 0) {
        image(upperTreeImg, tree.x, 0, 100 * scaleFactor, tree.gapY - 100 * scaleFactor);
      } else if (newTreeImg && newTreeImg.width > 0) {
        image(newTreeImg, tree.x, 0, 100 * scaleFactor, tree.gapY - 100 * scaleFactor);
      } else if (treeImg && treeImg.width > 0) {
        image(treeImg, tree.x, 0, 100 * scaleFactor, tree.gapY - 100 * scaleFactor);
      } else {
        fill(0, 128, 0);
        rect(tree.x, 0, 100 * scaleFactor, tree.gapY - 100 * scaleFactor);
      }

      // Zeichne das untere Hindernis mit Fallback
      if (newTreeImg && newTreeImg.width > 0) {
        image(newTreeImg, tree.x, tree.gapY + 150 * scaleFactor, 100 * scaleFactor, height - (tree.gapY + 150 * scaleFactor));
      } else if (treeImg && treeImg.width > 0) {
        image(treeImg, tree.x, tree.gapY + 150 * scaleFactor, 100 * scaleFactor, height - (tree.gapY + 150 * scaleFactor));
      } else {
        fill(0, 128, 0);
        rect(tree.x, tree.gapY + 150 * scaleFactor, 100 * scaleFactor, height - (tree.gapY + 150 * scaleFactor));
      }

      if (birdX + 25 * scaleFactor > tree.x && birdX - 25 * scaleFactor < tree.x + 100 * scaleFactor) {
        if (birdY - 25 * scaleFactor < tree.gapY - 100 * scaleFactor || birdY + 25 * scaleFactor > tree.gapY + 150 * scaleFactor) {
          resetGame();
        }
      }

      if (!tree.passed && birdX > tree.x + 100 * scaleFactor) {
        score += 1;
        tree.passed = true;
        obstaclesPassed += 1;
        if (obstaclesPassed % 3 === 0) {
          startQuiz();
        }
      }

      if (tree.x < -100 * scaleFactor) {
        trees.splice(i, 1);
      }
    }

    if (trees.length < 3 && obstaclePauseTimer <= 0) {
      spawnTree(width);
    }

    for (let i = pinecones.length - 1; i >= 0; i--) {
      let pinecone = pinecones[i];
      pinecone.x -= 2 * scaleFactor;
      if (newPineconeImg && newPineconeImg.width > 0) {
        image(newPineconeImg, pinecone.x, pinecone.y, 30 * scaleFactor, 30 * scaleFactor);
      } else if (pineconeImg) {
        image(pineconeImg, pinecone.x, pinecone.y, 30 * scaleFactor, 30 * scaleFactor);
      }

      if (birdX + 25 * scaleFactor > pinecone.x && birdX - 25 * scaleFactor < pinecone.x + 30 * scaleFactor &&
          birdY + 25 * scaleFactor > pinecone.y && birdY - 25 * scaleFactor < pinecone.y + 30 * scaleFactor) {
        score += 5;
        pinecones.splice(i, 1);
      }

      if (pinecone.x < -30 * scaleFactor) {
        pinecones.splice(i, 1);
      }
    }

    if (obstaclePauseTimer > 0) {
      obstaclePauseTimer--;
    }

    drawingContext.shadowBlur = 5;
    drawingContext.shadowColor = 'rgba(0, 0, 0, 0.5)';
    fill(255);
    textSize(32 * scaleFactor);
    text(`Punkte: ${score}`, width - 150 * scaleFactor, 40 * scaleFactor);
    drawingContext.shadowBlur = 0;
  } else if (gameState === 'quiz' && quiz) {
    if (quizFade < 1) {
      quizFade = min(quizFade + 0.02, 1);
    }

    fill(0, 0, 0, 200 * quizFade);
    rect(0, 0, width, height);

    let questionWidth = width * 0.8;
    let questionHeight = height * 0.15;
    let questionX = width / 2;
    let questionY = height / 4;

    drawingContext.shadowBlur = 10;
    drawingContext.shadowColor = 'rgba(0, 0, 0, 0.3)';
    fill(255, 255 * quizFade);
    rectMode(CENTER);
    rect(questionX, questionY, questionWidth, questionHeight, 15);
    drawingContext.shadowBlur = 0;

    textAlign(CENTER);
    let questionText = quiz && quiz.question ? quiz.question : 'Fehler: Frage nicht verfügbar';
    let baseFontSize = 28 * scaleFactor;
    textSize(baseFontSize);
    let textWidthValue = textWidth(questionText);
    let maxWidth = questionWidth * 0.9;
    let fontSize = baseFontSize;
    if (textWidthValue > maxWidth) {
      fontSize = baseFontSize * (maxWidth / textWidthValue);
      fontSize = max(fontSize, 16 * scaleFactor);
    }
    textSize(fontSize);
    drawingContext.shadowBlur = 5;
    drawingContext.shadowColor = 'rgba(0, 0, 0, 0.5)';
    fill(0);
    text(questionText, questionX, questionY + 10 * scaleFactor);
    drawingContext.shadowBlur = 0;

    const buttonColors = [
      [color(255, 99, 71), color(255, 140, 0)],
      [color(50, 205, 50), color(0, 255, 127)],
      [color(30, 144, 255), color(0, 191, 255)],
      [color(255, 215, 0), color(255, 165, 0)]
    ];

    rectMode(CENTER);
    let btnWidth = max(350 * scaleFactor, 250);
    let btnHeight = max(70 * scaleFactor, 60);
    let maxButtonWidth = btnWidth * 0.9;
    let baseAnswerFontSize = 24 * scaleFactor;

    let longestAnswer = quiz.options.reduce((a, b) => a.length > b.length ? a : b, '');
    textSize(baseAnswerFontSize);
    let longestAnswerWidth = textWidth(longestAnswer);
    let answerFontSize = baseAnswerFontSize;
    if (longestAnswerWidth > maxButtonWidth) {
      answerFontSize = baseAnswerFontSize * (maxButtonWidth / longestAnswerWidth);
      answerFontSize = max(answerFontSize, 14 * scaleFactor);
    }

    for (let i = 0; i < quiz.options.length; i++) {
      let x = width / 2;
      let y = height / 2 + i * 80 * scaleFactor - 40 * scaleFactor;
      let scale = 1;
      
      if (mouseX > x - btnWidth / 2 && mouseX < x + btnWidth / 2 && mouseY > y - btnHeight / 2 && mouseY < y + btnHeight / 2) {
        hoverIndex = i;
        scale = 1.1;
      } else if (hoverIndex === i) {
        hoverIndex = -1;
      }

      drawingContext.shadowBlur = 10;
      drawingContext.shadowColor = 'rgba(0, 0, 0, 0.3)';
      let gradient = drawingContext.createLinearGradient(x - btnWidth / 2, y, x + btnWidth / 2, y);
      gradient.addColorStop(0, buttonColors[i][0]);
      gradient.addColorStop(1, buttonColors[i][1]);
      drawingContext.fillStyle = gradient;
      rect(x, y, btnWidth * scale, btnHeight * scale, 15);
      drawingContext.shadowBlur = 0;

      drawingContext.shadowBlur = 5;
      drawingContext.shadowColor = 'rgba(0, 0, 0, 0.5)';
      fill(255, 255 * quizFade);
      textSize(answerFontSize);
      text(quiz.options[i], x, y + 8 * scaleFactor);
      drawingContext.shadowBlur = 0;
    }

    let barWidth = max(300 * scaleFactor, 200);
    let barHeight = max(20 * scaleFactor, 15);
    let barX = width / 2;
    let barY = height - 60 * scaleFactor;
    let timerProgress = quizTimer / (15 * 60);
    let filledWidth = barWidth * timerProgress;

    drawingContext.shadowBlur = 5;
    drawingContext.shadowColor = 'rgba(0, 0, 0, 0.3)';
    fill(100);
    rect(barX, barY, barWidth, barHeight, 10);
    let gradient = drawingContext.createLinearGradient(barX - barWidth / 2, barY, barX + barWidth / 2, barY);
    gradient.addColorStop(0, color(255, 99, 71));
    gradient.addColorStop(1, color(255, 215, 0));
    drawingContext.fillStyle = gradient;
    rectMode(CORNER);
    rect(barX - barWidth / 2, barY - barHeight / 2, filledWidth, barHeight, 10);
    rectMode(CENTER);
    drawingContext.shadowBlur = 0;

    drawingContext.shadowBlur = 3;
    drawingContext.shadowColor = 'rgba(0, 0, 0, 0.5)';
    fill(255, 255 * quizFade);
    textSize(16 * scaleFactor);
    text(ceil(quizTimer / 60), barX, barY + 5 * scaleFactor);
    drawingContext.shadowBlur = 0;

    quizTimer--;
    if (quizTimer <= 0) {
      gameState = 'playing';
      quiz = null;
      obstaclePauseTimer = 120;
    }
  } else if (gameState === 'quizResult') {
    fill(0, 0, 0, 200);
    rect(0, 0, width, height);

    textAlign(CENTER);
    textSize(48 * scaleFactor);
    drawingContext.shadowBlur = 10;
    drawingContext.shadowColor = 'rgba(0, 0, 0, 0.5)';
    fill(quizResultMessage === 'Richtig!' ? color(0, 255, 0) : color(255, 0, 0));
    text(quizResultMessage, width / 2, height / 2);
    drawingContext.shadowBlur = 0;

    quizResultTimer--;
    if (quizResultTimer <= 0) {
      if (totalQuestionsAnswered >= 15) {
        resetGame();
      } else {
        gameState = 'playing';
        quiz = null;
        obstaclePauseTimer = 120;
      }
    }
  } else if (gameState === 'gameover') {
    drawingContext.shadowBlur = 0;
    fill(0, 200);
    rect(0, 0, width, height);
    drawingContext.shadowBlur = 5;
    drawingContext.shadowColor = 'rgba(0, 0, 0, 0.5)';
    fill(255);
    textSize(32 * scaleFactor);
    textAlign(CENTER);
    text(`Punkte: ${score}`, width / 2, height / 2 - 40 * scaleFactor);
    text(`Richtige Fragen: ${correctAnswers}/15`, width / 2, height / 2);
    if (restartDelayTimer <= 0) {
      text("Drücke die Leertaste um neu zu starten", width / 2, height / 2 + 40 * scaleFactor);
    } else {
      text(`Neustart möglich in ${ceil(restartDelayTimer / 60)} Sekunden`, width / 2, height / 2 + 40 * scaleFactor);
    }
    drawingContext.shadowBlur = 0;

    if (restartDelayTimer > 0) {
      restartDelayTimer--;
    }

    if (!confettiPlayed && confetti.length === 0) {
      for (let i = 0; i < 100; i++) {
        confetti.push({
          x: random(width),
          y: random(-50, 0),
          size: random(5, 15) * scaleFactor,
          speed: random(2, 5) * scaleFactor,
          color: color(random(255), random(255), random(255)),
          rotation: random(TWO_PI),
          rotSpeed: random(-0.1, 0.1)
        });
      }
      confettiPlayed = true;
    }

    for (let i = confetti.length - 1; i >= 0; i--) {
      let c = confetti[i];
      c.y += c.speed;
      c.rotation += c.rotSpeed;
      push();
      translate(c.x, c.y);
      rotate(c.rotation);
      fill(c.color);
      rect(0, 0, c.size, c.size);
      pop();
      if (c.y > height) {
        confetti.splice(i, 1);
      }
    }
  }
}

function keyPressed() {
  if (key === ' ' && gameState === 'start') {
    startGame();
  } else if (key === ' ' && gameState === 'playing') {
    if (startDelayTimer > 0) {
      startDelayTimer = 0;
      gravityActive = true;
    }
    birdVelocity = -8 * scaleFactor;
  } else if (key === ' ' && gameState === 'gameover' && restartDelayTimer <= 0) {
    setup();
  }
}

function mousePressed() {
  handleInput();
}

function touchStarted() {
  handleInput();
  return false;
}

function handleInput() {
  if (gameState === 'start') {
    let btnWidth = max(200 * scaleFactor, 200);
    let btnHeight = max(60 * scaleFactor, 60);
    let btnX = width / 2;
    let btnY = height / 2 + 50 * scaleFactor;
    if (mouseX > btnX - btnWidth / 2 && mouseX < btnX + btnWidth / 2 &&
        mouseY > btnY - btnHeight / 2 && mouseY < btnY + btnHeight / 2) {
      startGame();
    }
  } else if (gameState === 'playing') {
    if (startDelayTimer > 0) {
      startDelayTimer = 0;
      gravityActive = true;
    }
    birdVelocity = -8 * scaleFactor;
  } else if (gameState === 'quiz' && quiz) {
    for (let i = 0; i < quiz.options.length; i++) {
      let x = width / 2;
      let y = height / 2 + i * 80 * scaleFactor - 40 * scaleFactor;
      let btnWidth = max(350 * scaleFactor, 250);
      let btnHeight = max(70 * scaleFactor, 60);
      let touchX = mouseX;
      let touchY = mouseY;
      if (touchX > x - btnWidth / 2 && touchX < x + btnWidth / 2 && touchY > y - btnHeight / 2 && touchY < y + btnHeight / 2) {
        totalQuestionsAnswered++;
        if (totalQuestionsAnswered > 15) totalQuestionsAnswered = 15;
        if (i === quiz.correct) {
          correctAnswers++;
          score += 10;
          quizResultMessage = 'Richtig!';
        } else {
          quizResultMessage = 'Falsch!';
        }
        gameState = 'quizResult';
        quizResultTimer = 120;
        break;
      }
    }
  } else if (gameState === 'gameover' && restartDelayTimer <= 0) {
    setup();
  }
}

function startGame() {
  gameState = 'playing';
  newBird = loadImage('./bird.png', 
    () => console.log('New Bird loaded successfully'), 
    () => {
      console.error('Failed to load ./bird.png, using placeholder');
      bird = loadImage('https://images.pexels.com/photos/326900/pexels-photo-326900.jpeg', 
        () => console.log('Bird placeholder loaded successfully'), 
        () => console.error('Failed to load bird placeholder image')
      );
    }
  );
  startDelayTimer = 120;
}

function spawnTree(x) {
  let minGap = 200 * scaleFactor;
  let maxGap = 400 * scaleFactor;
  let gapRange = maxGap - minGap;
  let difficultyFactor = constrain(score / 50, 0, 1);
  let gapSize = maxGap - gapRange * difficultyFactor;
  let gapY = random(gapSize, height - gapSize - 150 * scaleFactor);
  trees.push({ x: x, gapY: gapY, passed: false });
  if (random() < 0.5) {
    pinecones.push({ x: x + 150 * scaleFactor, y: gapY + 25 * scaleFactor });
  }
}

function startQuiz() {
  if (currentQuestionIndex < shuffledQuestions.length) {
    gameState = 'quiz';
    quiz = shuffledQuestions[currentQuestionIndex];
    currentQuestionIndex++;
    quizTimer = 15 * 60;
    quizFade = 0;
    console.log('Quiz started:', quiz.question, 'Options:', quiz.options);
  } else {
    resetGame();
  }
}

function resetGame() {
  gameState = 'gameover';
  confetti = [];
  confettiPlayed = false;
  restartDelayTimer = 300;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  scaleFactor = min(windowWidth / 800, windowHeight / 600);
  birdX = width / 4;
  birdY = height / 2;
}
</script>
</body>
</html>
